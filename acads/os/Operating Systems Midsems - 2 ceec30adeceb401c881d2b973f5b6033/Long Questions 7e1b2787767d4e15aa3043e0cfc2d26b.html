<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Long Questions</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-opaquegray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="7e1b2787-767d-4e15-aa30-43e0cfc2d26b" class="page sans"><header><h1 class="page-title">Long Questions</h1></header><div class="page-body"><ol type="1" id="c412cec8-6b5e-4da6-a3a9-2b6b77391f6f" class="numbered-list" start="1"><li><strong>Explain Deadlock Handling methods?</strong><p id="5333db5c-bf72-4ad2-bff1-9d4b8a77d2d1" class="">There are several methods for handling deadlocks in a computer system:</p><ol type="1" id="96c22d98-5e25-4b59-8883-350f46ba17b1" class="numbered-list" start="1"><li>Prevention: This involves designing algorithms and systems that avoid the four necessary conditions for a deadlock to occur. This can be done by avoiding circular waits, allowing resources to be preempted, or limiting the number of resources that a process can request at once.</li></ol><ol type="1" id="977e7994-2e9f-4ae4-8708-b3954d330451" class="numbered-list" start="2"><li>Detection and Recovery: This involves detecting deadlocks when they occur and recovering from them by releasing resources and terminating processes. Deadlock detection can be done by using various algorithms, such as resource allocation graphs, wait-for graphs, or time-out mechanisms.</li></ol><ol type="1" id="ec7ac8c9-a0cb-4be5-9aca-d01b1ea62892" class="numbered-list" start="3"><li>Ignoring Deadlocks: In some systems, deadlocks may be ignored, as they may not be considered a significant problem. For example, in single-user systems or systems with low-level processes, deadlocks may not cause significant harm.</li></ol><ol type="1" id="aa6ad31b-21c2-4927-93c7-3cbb44a6c2eb" class="numbered-list" start="4"><li>Deadlock Avoidance: This involves dynamically avoiding deadlocks by allowing processes to request resources in such a way that the four necessary conditions for a deadlock cannot occur. This can be done by using resource allocation algorithms that ensure that the system remains in a safe state, or by using algorithms that allow processes to roll back their resource requests if they detect a potential deadlock.</li></ol><ol type="1" id="a54aaa2e-8db6-4c13-a47a-e9649bca03e9" class="numbered-list" start="5"><li>Deadlock Prevention using Time-Out Mechanism: In this method, each process is assigned a time-out value, and if it does not receive the requested resource within that time, it releases all of its resources and terminates. This method helps to avoid deadlocks, but can result in processes being terminated prematurely.</li></ol><p id="ad6b21c0-8a34-49b0-a931-82a90e22f14a" class="">These are some of the methods for handling deadlocks in a computer system. The method used will depend on the requirements of the system and the trade-offs between the costs and benefits of each approach.</p><hr id="834dd07c-7dd7-4f94-8417-34b553c960cb"/></li></ol><ol type="1" id="8b5dee75-ee6e-45a7-b3a6-69b6a57e9bfe" class="numbered-list" start="2"><li><strong>Describe Producer and Consumer problem ? Describe Reader’s and Writer’s problem?</strong><ol type="a" id="7146d540-9e39-43b9-97b2-6647c3e18498" class="numbered-list" start="1"><li>Producer and Consumer Problem: The producer and consumer problem is a classical synchronization problem that occurs in computer programming when multiple processes share a common buffer. The producer process generates data and places it in the buffer, while the consumer process retrieves the data from the buffer. The goal is to ensure that the producer and consumer processes coordinate their actions so that the buffer is used efficiently and the data is not lost.</li></ol><ol type="a" id="7f4269ff-2f05-41eb-8748-f0734d43bfa9" class="numbered-list" start="2"><li>Reader and Writer Problem: The reader and writer problem is a synchronization problem that occurs in computer programming when multiple processes share a common resource, such as a database or a file. The reader processes want to read the data, while the writer processes want to write to the data. The goal is to ensure that the readers and writers coordinate their actions so that the resource is used efficiently and data is not lost or corrupted.</li></ol><p id="b6d0efb4-62f3-4571-a59a-348eb53b35f8" class="">In both of these problems, it is important to use synchronization techniques, such as locks or semaphores, to ensure that only one process can access the buffer or resource at a time. This can prevent race conditions, deadlocks, or other synchronization issues that can cause incorrect results or harm the system.</p><hr id="35586171-24eb-439a-82f3-1a57d588b0cf"/></li></ol><ol type="1" id="89827cbf-7db3-4c6f-891b-4696389bbe21" class="numbered-list" start="3"><li><strong>What is non-contiguous memory management technique?</strong><p id="a5497e20-ca81-4038-b550-700fc0f06f9e" class="">Non-contiguous memory management is a technique used in computer systems to manage memory allocation when the available memory is not physically contiguous in the computer&#x27;s memory. In such systems, multiple blocks of memory are spread throughout the physical memory, and the operating system must use various techniques to allocate and manage these non-contiguous blocks of memory.</p><p id="7fcd341f-9123-4c88-9d21-acdc81737426" class="">One common technique for non-contiguous memory management is paging, which involves dividing the memory into fixed-size pages and storing each process&#x27;s memory in separate pages.</p><p id="b553876f-4a5b-45d3-8d45-f2f03fa77803" class="">Non-contiguous memory management is a technique used in computer systems to manage memory allocation when the available memory is not physically contiguous in the computer&#x27;s memory. In these systems, the memory is divided into small blocks, which are spread throughout the physical memory and are not located next to each other.</p><p id="df88813f-e285-4958-9ca4-de8ff4368ccb" class="">The challenge in non-contiguous memory management is to allocate memory to processes efficiently, so that each process has the memory it needs to run and store data, while ensuring that the memory is used effectively. The operating system must use various techniques to allocate and manage these non-contiguous blocks of memory.</p><p id="a1bc53db-ae64-4b9e-8151-31ab5f77d819" class="">One common technique for non-contiguous memory management is paging, which involves dividing the memory into fixed-size pages and storing each process&#x27;s memory in separate pages. The operating system can allocate memory to processes by assigning pages of memory to them. When a process requires more memory, the operating system can allocate additional pages. When a process is terminated, its pages can be freed and used by other processes.</p><p id="ed250391-57b3-4fce-9191-190f85d27357" class="">Another technique is segmentation, which involves dividing memory into variable-sized segments, each of which can be assigned to a different process. Segmentation allows processes to have different sizes of memory and allows the operating system to allocate memory to processes more efficiently. The operating system can allocate memory to processes by assigning segments of memory to them. When a process requires more memory, the operating system can allocate additional segments. When a process is terminated, its segments can be freed and used by other processes.</p><p id="a2e7190c-ceb5-4f6e-bdb6-8d6f1648831a" class="">Both paging and segmentation are used to manage non-contiguous memory in modern computer systems. The choice of which technique to use depends on the requirements of the system and the trade-offs between the costs and benefits of each approach.</p><p id="720aacf3-0da7-491b-9e41-3eac0de32790" class="">In summary, non-contiguous memory management is a technique used in computer systems to allocate and manage memory in an effective and efficient manner, when the available memory is not physically contiguous. The operating system uses techniques such as paging and segmentation to allocate and manage the memory blocks, and ensures that each process has the memory it needs to run and store data.</p><hr id="b9744f8d-2fb5-4475-8312-b074e7c39564"/></li></ol><ol type="1" id="43ecca99-8b08-44cf-9cb4-75c7f8b5f0c9" class="numbered-list" start="4"><li><strong>Briefly Describe PAGING and SEGMENTATION?</strong><p id="54f55023-8c8d-4dc4-ba15-27b32f22aa04" class="">Paging: Paging is a technique used in computer systems to manage non-contiguous memory allocation. It involves dividing the memory into fixed-size pages and storing each process&#x27;s memory in separate pages. The operating system allocates memory to processes by assigning pages of memory to them. When a process requires more memory, the operating system can allocate additional pages. When a process is terminated, its pages can be freed and used by other processes. Paging is used to manage memory effectively and efficiently in modern computer systems.</p><p id="ffe3763b-baed-429f-ada4-d86dce3fa486" class="">Segmentation: Segmentation is another technique used in computer systems to manage non-contiguous memory allocation. It involves dividing the memory into variable-sized segments, each of which can be assigned to a different process. Segmentation allows processes to have different sizes of memory and allows the operating system to allocate memory to processes more efficiently. The operating system allocates memory to processes by assigning segments of memory to them. When a process requires more memory, the operating system can allocate additional segments. When a process is terminated, its segments can be freed and used by other processes. Segmentation is used in conjunction with paging in modern computer systems to manage memory effectively and efficiently.</p><hr id="c89ada78-b5d5-49b4-a5b3-0df7d6c837b6"/></li></ol><ol type="1" id="1814d461-82d4-48a3-92c5-eef187ed88c3" class="numbered-list" start="5"><li><strong>Explain  i) Demand paging  ii) Page Replacement iii) Swaping iii) Page Replacement                    algorithms</strong><p id="6d312aac-b786-4e2d-9f9c-bbce11a4e75a" class="">i) Demand Paging: Demand paging is a technique used in computer systems to load only the pages of a process into memory that are required to execute the process. The operating system maintains a page table for each process, which stores the status of each page of the process, such as whether it is in memory or on disk. When a process is executed, the operating system checks the page table to determine which pages of the process are in memory and which are on disk. If a page is not in memory, the operating system loads it from disk into memory, a process known as page fault. Demand paging allows the operating system to allocate memory to processes more efficiently and reduces the amount of memory required to run processes.</p><p id="3bb2c0bc-c1a6-42a7-b980-d5b4743a1b1f" class="">ii) Page Replacement: Page replacement is a technique used in computer systems to free up memory when a process requires more memory than is available. The operating system selects a page in memory to replace with a new page that is required by the process. The operating system selects the page to replace based on the page replacement algorithm. Common page replacement algorithms include First-In-First-Out (FIFO), Least Recently Used (LRU), and Optimal.</p><p id="e44fab79-e89e-4fae-974a-2af0be16c849" class="">iii) Swapping: Swapping is a technique used in computer systems to temporarily move a process from memory to disk. The operating system moves a process from memory to disk when it requires more memory than is available. The process can be restored to memory later when memory becomes available. Swapping allows the operating system to allocate memory to processes more efficiently, but it can be slow because disk access is much slower than memory access.</p><p id="076122ab-326e-4f7a-ba87-7837b01e0b35" class="">iv) Page Replacement Algorithms: Page replacement algorithms are used by the operating system to determine which page to replace when a page fault occurs. There are several page replacement algorithms, including:</p><ul id="7ed19d64-526f-4c54-a7d1-899355b30bbe" class="bulleted-list"><li style="list-style-type:disc">First-In-First-Out (FIFO): The oldest page in memory is replaced.</li></ul><ul id="282bed29-615e-4195-a088-ee3659bcce8a" class="bulleted-list"><li style="list-style-type:disc">Least Recently Used (LRU): The page that has not been used for the longest time is replaced.</li></ul><ul id="e9db4eaf-2edb-4599-992d-909bdb8fab29" class="bulleted-list"><li style="list-style-type:disc">Optimal: The page that will not be used for the longest time in the future is replaced.</li></ul><ul id="4d5e7059-cb92-4f69-b9e2-a2f4cb89a2e8" class="bulleted-list"><li style="list-style-type:disc">Second Chance: A modified version of the FIFO algorithm, where the operating system checks the reference bit of each page before deciding to replace it.</li></ul><p id="743764a3-ef39-484c-9a70-6588c0d58c45" class="">Each page replacement algorithm has its own advantages and disadvantages, and the choice of which algorithm to use depends on the requirements of the system and the trade-offs between the costs and benefits of each approach.</p><hr id="064622dd-16ba-4c4e-9c7c-bf10c25995b5"/></li></ol><ol type="1" id="f193277d-00bc-47e9-89fd-fe9ee48691dc" class="numbered-list" start="6"><li><strong>Describe File System Interface and Operations? File allocation Strategies?</strong><p id="dde1cbea-8944-43d3-ac47-272ecd2b9a43" class="">File System Interface and Operations: A file system interface is a set of commands, system calls, and libraries that provide an application program with access to the file system. File system operations include creating, reading, writing, and deleting files, as well as managing directories and file attributes. Examples of file system interfaces include the standard I/O library in Unix-like systems, the Win32 API in Windows, and the Java file I/O library in Java.</p><p id="d446e14a-9fb9-4e15-b36a-9b8add45d8e6" class="">File Allocation Strategies: A file allocation strategy is a method used to manage the allocation of disk space to files. The objective of a file allocation strategy is to minimize fragmentation, maximize disk space utilization, and provide fast access to files. There are several file allocation strategies, including:</p><ul id="98b0f840-3b2b-48fa-bc65-8d562b500a9b" class="bulleted-list"><li style="list-style-type:disc">Contiguous Allocation: Files are stored in contiguous blocks of disk space. This approach is simple and provides fast access to files, but can lead to fragmentation as files are deleted and created.</li></ul><ul id="109f5082-8648-4715-843f-fb2180e4eed7" class="bulleted-list"><li style="list-style-type:disc">Linked Allocation: Files are stored as a linked list of disk blocks. This approach eliminates fragmentation, but can be slow for large files because disk access is required for each block in the file.</li></ul><ul id="bbb4cc3c-f2af-45af-89f0-149ebc012b7c" class="bulleted-list"><li style="list-style-type:disc">Indexed Allocation: Files are stored as an index of disk blocks. This approach provides fast access to files, eliminates fragmentation, and can handle large files efficiently.</li></ul><ul id="4b8aeccc-7917-4d49-87c1-55e413d52fb2" class="bulleted-list"><li style="list-style-type:disc">Extendible Hashing: A dynamic data structure used to implement indexed allocation, which allows the number of disk blocks used to store a file to grow as the file grows.</li></ul><p id="84f9586d-ba5b-4341-b8c8-452263dbdb57" class="">The choice of file allocation strategy depends on the requirements of the system and the trade-offs between the costs and benefits of each approach. For example, contiguous allocation is well suited for small files, while indexed allocation is better for large files and for systems with high disk utilization.</p><hr id="0845c927-704d-4b43-9fc7-1f65573f4f53"/></li></ol><ol type="1" id="c240a86e-52f0-4f26-a9cd-0ed62536e56a" class="numbered-list" start="7"><li><strong>What is the usage of open, create, read, write, close, lseek, stat, ioctl, system calls</strong><ol type="a" id="cb818741-47ce-4db1-af4d-420705bf96f8" class="numbered-list" start="1"><li>open() system call is used to open a file for reading, writing or both. It returns a file descriptor, which is a small integer that represents the file and is used in subsequent file operations.</li></ol><ol type="a" id="ef74ca53-3971-4e2d-89a6-5effc3f0b895" class="numbered-list" start="2"><li>create() system call is used to create a new file or overwrite an existing file. This system call is usually implemented as a library function that uses the open() system call.</li></ol><ol type="a" id="2f97e9dd-77ea-43fc-b65f-ad7b09c71d73" class="numbered-list" start="3"><li>read() system call is used to read data from a file into a buffer. The file is specified by its file descriptor, and the data is read into the buffer starting at the current file position.</li></ol><ol type="a" id="463e7f5a-c394-449f-ad9e-378b7b6160c3" class="numbered-list" start="4"><li>write() system call is used to write data from a buffer to a file. The file is specified by its file descriptor, and the data is written to the file starting at the current file position.</li></ol><ol type="a" id="cec5b399-9ab5-4640-bb0e-696e67e8ed2c" class="numbered-list" start="5"><li>close() system call is used to close a file. It releases the file descriptor and any resources associated with the file, making it available for reuse by the operating system.</li></ol><ol type="a" id="ce84fcaf-cd9e-4f99-a9b0-2fafdfb7ccdc" class="numbered-list" start="6"><li>lseek() system call is used to change the current file position of a file. This system call allows a program to read or write a specific portion of a file, rather than starting at the beginning or the end.</li></ol><ol type="a" id="6fdeed0f-36a2-4f66-87b9-1d1e221bcf16" class="numbered-list" start="7"><li>stat() system call is used to retrieve information about a file, such as its size, creation time, and access permissions.</li></ol><ol type="a" id="f09a43c7-d928-449c-a3f6-242379dcc151" class="numbered-list" start="8"><li>ioctl() system call is used to perform various device-specific operations. It can be used to control the behavior of device drivers, or to retrieve information about the status of a device.</li></ol><ol type="a" id="a551fc06-d5aa-45ef-aa4e-25d55445f43c" class="numbered-list" start="9"><li>The system() system call is used to execute a shell command in a separate process. This system call can be used to run other programs, or to perform shell operations like creating pipes, redirecting input and output, and creating background processes.</li></ol><hr id="b3f194d0-c935-4fdf-8234-b29da848ab76"/></li></ol><ol type="1" id="79a18b28-f7aa-4703-aea2-de76f415a3d6" class="numbered-list" start="8"><li><strong>What is synchronization? What are the different synchronization mechanisms?</strong><p id="c0aef55b-8205-4cb9-ac28-7a2aa1bc4062" class="">Synchronization is the process of coordinating the actions of multiple threads or processes to ensure that they execute in a specific order, avoiding inconsistencies in shared data or resources.</p><p id="7560567e-4e9d-4287-87bc-4a437cfeb690" class="">Different synchronization mechanisms include:</p><ol type="1" id="428dda08-b855-4f6f-9b9d-f236eb44f1a6" class="numbered-list" start="1"><li>Mutex (Mutual Exclusion) locks: Used to prevent multiple threads from accessing shared data simultaneously. Only one thread can hold the lock at a time, and other threads wait for the lock to be released.</li></ol><ol type="1" id="b14c4793-5974-4f97-b995-fe52c4188e52" class="numbered-list" start="2"><li>Semaphores: A synchronization mechanism that uses a counter to control access to shared resources. When a thread decrements the semaphore counter to zero, it acquires the resource and other threads are blocked.</li></ol><ol type="1" id="dc4ff473-697e-4b56-82ed-d8e329c56222" class="numbered-list" start="3"><li>Monitors: A synchronization mechanism that provides a way to define a critical section of code, in which only one thread can execute at a time. The monitor automatically locks and unlocks the critical section as threads enter and exit it.</li></ol><ol type="1" id="fe058dcc-d4b4-4803-a3b3-deb1b692b4f4" class="numbered-list" start="4"><li>Condition variables: A synchronization mechanism used to block and unblock threads in order to wait for specific conditions. A thread waiting on a condition variable is blocked until another thread signals the condition variable.</li></ol><ol type="1" id="20365d72-3036-4f59-a9bb-835299485adb" class="numbered-list" start="5"><li>Spin locks: A synchronization mechanism used to implement mutual exclusion in real-time systems. Spin locks busy-wait for the lock to be released, consuming CPU cycles until the lock is acquired.</li></ol><ol type="1" id="a060102a-fe59-4b1e-b807-38ee1d2ab5d0" class="numbered-list" start="6"><li>Reader-writer locks: A synchronization mechanism used to synchronize access to shared data that is read and written by multiple threads. Reader-writer locks allow multiple threads to read the shared data simultaneously, but only one thread can write the data at a time.</li></ol><hr id="7d82404e-905d-4a77-bbcf-ec529ad49e92"/></li></ol><ol type="1" id="2af1d57c-7e53-434a-9c71-bc0b20630daa" class="numbered-list" start="9"><li><strong>What is a Semaphore ? Solution for Dining Philosophers problem using Semaphore?</strong><p id="98da89f7-1604-454f-97ed-8cc66267a32b" class="">A semaphore is a synchronization mechanism that uses a counter to control access to shared resources. It is used to synchronize the execution of threads, so that only a limited number of threads can access the shared resource at the same time.</p><p id="fb8901de-7745-4d29-be46-873c1b0a0b9b" class="">The Dining Philosophers problem is a classic problem in computer science that demonstrates the need for synchronization. The problem involves five philosophers sitting at a round table, each with a plate of food and a fork. The philosophers alternate between thinking and eating, and they need to use both forks to eat.</p><p id="4a5aebb4-fe8c-49d8-b003-5bc0fdab9072" class="">A solution to the Dining Philosophers problem using semaphores can be implemented as follows:</p><ol type="1" id="3639f9c0-64f9-4f5e-8e9a-9c33f815fbc8" class="numbered-list" start="1"><li>Define a semaphore for each fork, and initialize each semaphore with a value of 1 to indicate that the fork is available.</li></ol><ol type="1" id="1772012f-b1ab-4387-b5f4-5cd582cc40c4" class="numbered-list" start="2"><li>Create a semaphore for each philosopher, and initialize it with a value of 0 to indicate that the philosopher is not eating.</li></ol><ol type="1" id="8e2ec84b-8c16-41ed-b6a1-b67785968065" class="numbered-list" start="3"><li>Each philosopher attempts to acquire both of its neighboring forks by waiting on the corresponding semaphores. If both forks are available, the philosopher increments the value of the semaphores to indicate that the forks are in use.</li></ol><ol type="1" id="35e5b3f4-395b-4977-96fc-5a8bebf8a631" class="numbered-list" start="4"><li>When the philosopher has finished eating, it releases both forks by decrementing the value of the corresponding semaphores.</li></ol><ol type="1" id="3072b631-a264-4be7-84f9-2cdfb9752e2c" class="numbered-list" start="5"><li>The semaphores ensure that only one philosopher can eat at a time, and that each philosopher can only eat if both of its forks are available.</li></ol><p id="cae461eb-171e-4732-baf2-d72cefa96f7f" class="">By using semaphores, the Dining Philosophers problem can be solved in a way that avoids deadlocks and starvation. The semaphores provide a mechanism for coordinating the execution of the philosophers and synchronizing access to the shared resources (the forks).</p><hr id="52735f4c-9f95-48f9-a6ff-b5f1d6adf8f7"/></li></ol><ol type="1" id="f295ee4d-ee28-4c6a-9693-75b5cef3b3c1" class="numbered-list" start="10"><li><strong>Assume that there are 3 page frames which are initially empty. If the page reference string is        1, 2, 3, 4, 2, 1, 5, 3, 2, 4, 6, find  the number of page faults using the</strong><ol type="a" id="e63a7afe-0aaf-4a6a-a9e9-a0ed83cecfbf" class="numbered-list" start="1"><li>LRU</li></ol><ol type="a" id="fc8f3d0e-efcd-4072-9f7d-f31cc25e04ab" class="numbered-list" start="2"><li>FIFO</li></ol><ol type="a" id="064d06dd-a00c-469a-bcce-88ad32252aa1" class="numbered-list" start="3"><li>Optimal Replacement</li></ol><p id="b997c5f9-34b6-4c34-86f5-8105961aadbb" class="">Here is the number of page faults for each page replacement algorithm, assuming there are 3 page frames:</p><ol type="1" id="d806de90-89a0-437f-b0ef-9afa8e1b33fd" class="numbered-list" start="1"><li>LRU (Least Recently Used):<ul id="b87cf9c4-c4d7-4dad-a2e6-0a593ff21fc6" class="bulleted-list"><li style="list-style-type:disc">The page reference string is 1, 2, 3, 4, 2, 1, 5, 3, 2, 4, 6.</li></ul><ul id="dd327590-f979-4b8c-afbf-ebb94ff0db6b" class="bulleted-list"><li style="list-style-type:disc">Initial state: All frames are empty.</li></ul><ul id="8f67868e-8da1-4813-a3bd-c9478919aa45" class="bulleted-list"><li style="list-style-type:disc">Step 1: 1 is loaded into frame 1, page fault = 1.</li></ul><ul id="d766aa78-b5ac-4952-83b5-135f53dfd566" class="bulleted-list"><li style="list-style-type:disc">Step 2: 2 is loaded into frame 2, page fault = 2.</li></ul><ul id="1a3beeb9-39cd-4849-87f0-b348ea79543a" class="bulleted-list"><li style="list-style-type:disc">Step 3: 3 is loaded into frame 3, page fault = 3.</li></ul><ul id="6b719d73-f620-4fb5-8059-ed7330eb3dc3" class="bulleted-list"><li style="list-style-type:disc">Step 4: 4 is loaded into frame 1, page fault = 4.</li></ul><ul id="f20bbefb-67b2-49e9-817a-e5f755c2fd46" class="bulleted-list"><li style="list-style-type:disc">Step 5: 2 is already in frame 2, no page fault.</li></ul><ul id="4ad01f1d-9096-4d5c-9c07-d94e088cea68" class="bulleted-list"><li style="list-style-type:disc">Step 6: 1 is already in frame 1, no page fault.</li></ul><ul id="904422ea-a7b0-478e-b2f3-00c30aa04af7" class="bulleted-list"><li style="list-style-type:disc">Step 7: 5 is loaded into frame 3, page fault = 5.</li></ul><ul id="84c1f81f-ed35-4717-9ced-8901652d0716" class="bulleted-list"><li style="list-style-type:disc">Step 8: 3 is already in frame 3, no page fault.</li></ul><ul id="70b3f251-a3d4-429e-ad63-212465a2637d" class="bulleted-list"><li style="list-style-type:disc">Step 9: 2 is already in frame 2, no page fault.</li></ul><ul id="666043e1-58a0-46b2-9c1a-926c233e1f42" class="bulleted-list"><li style="list-style-type:disc">Step 10: 4 is already in frame 1, no page fault.</li></ul><ul id="7dfec520-3776-4e65-a4b0-a2b8446223cb" class="bulleted-list"><li style="list-style-type:disc">Step 11: 6 is loaded into frame 2, page fault = 6.</li></ul><ul id="09d3cb9d-f3bb-4c9f-8b40-3a1611c3c522" class="bulleted-list"><li style="list-style-type:disc">Total number of page faults = 6.</li></ul></li></ol><ol type="1" id="8f48e624-161b-40b9-9c85-8ad0ce0dae6e" class="numbered-list" start="2"><li>FIFO (First In First Out):<ul id="eb8e1e85-34a6-4c79-b923-0d6e91f3abc9" class="bulleted-list"><li style="list-style-type:disc">The page reference string is 1, 2, 3, 4, 2, 1, 5, 3, 2, 4, 6.</li></ul><ul id="0d4f16bf-df5e-4b17-b413-91eb1db51fe4" class="bulleted-list"><li style="list-style-type:disc">Initial state: All frames are empty.</li></ul><ul id="f939ab71-3ceb-45e1-89e7-cd28a09823a7" class="bulleted-list"><li style="list-style-type:disc">Step 1: 1 is loaded into frame 1, page fault = 1.</li></ul><ul id="e980e731-53a9-44ec-9b9d-0e4a882b2ba8" class="bulleted-list"><li style="list-style-type:disc">Step 2: 2 is loaded into frame 2, page fault = 2.</li></ul><ul id="f9e90716-e5d9-4de6-960d-4089ef5522e3" class="bulleted-list"><li style="list-style-type:disc">Step 3: 3 is loaded into frame 3, page fault = 3.</li></ul><ul id="a1bf6a02-c8f3-40d5-923b-cddc33c96d06" class="bulleted-list"><li style="list-style-type:disc">Step 4: 4 is loaded into frame 1, page fault = 4.</li></ul><ul id="1d3d238b-3a4a-405a-b977-d0088d253c39" class="bulleted-list"><li style="list-style-type:disc">Step 5: 2 is already in frame 2, no page fault.</li></ul><ul id="27a17932-8190-4b9d-9ea0-fbcfb5349d2e" class="bulleted-list"><li style="list-style-type:disc">Step 6: 1 is already in frame 1, no page fault.</li></ul><ul id="f27560f2-83c0-4ae0-9eb5-6bf049540797" class="bulleted-list"><li style="list-style-type:disc">Step 7: 5 is loaded into frame 2, page fault = 5.</li></ul><ul id="aaa69243-cb2b-4eea-adb6-7cb0316cb553" class="bulleted-list"><li style="list-style-type:disc">Step 8: 3 is already in frame 3, no page fault.</li></ul><ul id="d3e270bc-e132-475a-9456-d66649e01ab4" class="bulleted-list"><li style="list-style-type:disc">Step 9: 2 is already in frame 2, no page fault.</li></ul><ul id="c0f7523b-89a4-4bac-b2c1-4a1a3ac77778" class="bulleted-list"><li style="list-style-type:disc">Step 10: 4 is already in frame 1, no page fault.</li></ul><ul id="93109d2a-0692-4f81-aba2-8762fd245945" class="bulleted-list"><li style="list-style-type:disc">Step 11: 6 is loaded into frame 3, page fault = 6.</li></ul><ul id="a6081756-402f-40c2-9d50-ba86f35f7643" class="bulleted-list"><li style="list-style-type:disc">Total number of page faults = 6.</li></ul></li></ol><ol type="1" id="9268ddc0-84d1-4599-9f1c-9551cde950a3" class="numbered-list" start="3"><li>Optimal Replacement:<ul id="db9b8f1b-56f8-4045-b5fb-bac5d7503fb2" class="bulleted-list"><li style="list-style-type:disc">The page reference string is 1, 2, 3, 4, 2, 1, 5, 3, 2, 4, 6.</li></ul><ul id="527c9f60-86bb-47d3-992b-c10a34a8a811" class="bulleted-list"><li style="list-style-type:disc">Initial state: All frames are empty.</li></ul><ul id="68f8dab1-a60d-4e1d-8b2b-00ad11ffc9a4" class="bulleted-list"><li style="list-style-type:disc">Step 1: 1 is loaded into frame 1, page fault = 1.</li></ul><ul id="00e6fa69-83c1-478a-aaee-46a24d95f4b5" class="bulleted-list"><li style="list-style-type:disc">Step 2: 2 is loaded into frame 2, page fault = 2.</li></ul><ul id="39fb3b77-e1a4-480f-9d2c-14b159147b30" class="bulleted-list"><li style="list-style-type:disc">Step 3: 3 is loaded into frame 3, page fault = 3.</li></ul><ul id="6b327b55-9c53-45c5-95c6-fa722b807062" class="bulleted-list"><li style="list-style-type:disc">Step 4: 4 is loaded into frame 1, page fault = 4.</li></ul><ul id="e9496185-f83d-4b86-95e0-c3b03086dbad" class="bulleted-list"><li style="list-style-type:disc">Step 5: 2 is already in frame 2, no page fault.</li></ul><ul id="420078f0-2a46-4b9c-a208-dc97ce3b111c" class="bulleted-list"><li style="list-style-type:disc">Step 6: 1 is already in frame 1, no page fault.</li></ul><ul id="5b07bda8-3f9b-4600-a773-d994a9cc06b9" class="bulleted-list"><li style="list-style-type:disc">Step 7: 5 is loaded into frame 3, page fault = 5.</li></ul><ul id="29d07756-fd61-4421-a4f6-af7988fb7c45" class="bulleted-list"><li style="list-style-type:disc">Step 8: 3 is already in frame 3, no page fault.</li></ul><ul id="4e5a3f63-271a-47bc-a9fc-ccd10e53e1fb" class="bulleted-list"><li style="list-style-type:disc">Step 9: 2 is already in frame 2, no page fault.</li></ul><ul id="8be188ab-4e01-466a-b224-a7b0ffad97c6" class="bulleted-list"><li style="list-style-type:disc">Step 10: 4 is already in frame 1, no page fault.</li></ul><ul id="e6b3d098-9111-4fa2-813e-6b2e0f9cd4e9" class="bulleted-list"><li style="list-style-type:disc">Step 11: 6 is loaded into frame 1, page fault = 6</li></ul><ul id="d08503aa-6af6-4253-a01c-7bcb44c01da2" class="bulleted-list"><li style="list-style-type:disc">Total number of page faults = 6.</li></ul><hr id="4b1f152e-e3b9-4c08-bd50-5260bbdab6b9"/></li></ol></li></ol><ol type="1" id="c8c503d8-9d79-48cf-80ce-9ee5e29813ce" class="numbered-list" start="11"><li><strong>Explain Contigous memory allocation techniques ?</strong><p id="b6dd6f2f-0750-4aa9-8336-8db979034158" class="">Contiguous memory allocation is a method of allocating memory blocks in a contiguous (adjacent) manner. There are two main contiguous memory allocation techniques:</p><ol type="1" id="022c36ae-25b2-4c10-b20f-9160b1b82ff5" class="numbered-list" start="1"><li>First-Fit: This method allocates the first available block of sufficient size that it finds in the memory. It starts searching from the beginning of the memory and continues until it finds a suitable block.</li></ol><ol type="1" id="43bc9f27-6ff1-4edd-b324-4e0f4fc3837f" class="numbered-list" start="2"><li>Best-Fit: This method allocates the smallest available block of sufficient size that it finds in the memory. It searches the entire memory to find the best block to allocate. This method minimizes the amount of internal fragmentation, but takes longer to allocate memory than First-Fit.</li></ol><p id="6add9122-f0db-4ecd-9037-7c6e3385211d" class="">In both of these techniques, the allocated block is split into two parts: the portion that holds the requested data and the unused portion (internal fragmentation).</p></li></ol><hr id="17dc229c-d5d0-4d9f-b8f3-08fb9b32a3d1"/><p id="c056ebf3-8173-4ada-a911-ec98ebda2f1d" class="">
</p></div></article></body></html>